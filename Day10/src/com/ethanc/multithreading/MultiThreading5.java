package com.ethanc.multithreading;

/*
 * 什么是线程安全问题？多个线程，同时操作同一个共享资源的时候，可能会出现业务安全问题。
 * 线程安全问题出现的原因？
 * - 存在多个线程在同时执行
 * - 同时访问一个共享资源
 * - 存在修改该共享资源
 *  解决：让多个线程以此访问共享资源
 *
 * 加锁：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来。
 * 1. 同步代码块
 * - 作用：把访问共享资源的核心代码给上锁，以此保证线程安全。
 * synchronized(同步锁) {
 *     访问共享资源的核心代码
 * }
 *
 * - 原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行。
 *
 * 同步锁的注意事项
 * - 对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出现bug。
 *
 * 锁对象随便选择一个唯一的对象好不好呢？
 * - 不好，会影响其他无关线程的执行。
 *
 * 锁对象的使用规范
 * - 建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象。
 * - 对于静态方法建议使用字节码（类名.class）对象作为锁对象。
 *
 * 2. 同步方法
 * 作用：把访问共享资源的核心方法给上锁，以此保证线程安全。
 * 修饰符 synchronized 返回值类型 方法名称(形参列表) {
 *     操作共享资源的代码
 * }
 * 作用：把访问共享资源的核心方法给上锁，以此保证线程安全。
 * 原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行。
 *
 * 同步方法底层原理
 * - 同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。
 * - 如果方法是实例方法：同步方法默认用this作为的锁对象。
 * - 如果方法是静态方法：同步方法默认用类名.class作为的锁对象。
 *
 * 两者适用情况：
 * - 范围上：同步代码块锁的范围更小，同步方法锁的范围更大
 * - 可读性：同步方法更好
 *
 * 3. Lock锁
 * Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建出锁对象进行加锁和解锁，更灵活、更方便、更强大。
 *
 * Lock是接口，不能直接实例化，可以采用它的实现类ReentrantLock来构建Lock锁对象。
 *
 * | 构造器                | 说明                     |
 * |-----------------------|--------------------------|
 * | public ReentrantLock() | 获得Lock锁的实现类对象    |
 *
 * 方法：先通过构造器获得Lock锁对象，然后调用方法上锁、开锁
 * 1. .lock()   上锁
 * 2. .unlock() 开锁
 */
public class MultiThreading5 {
    public static void main(String[] args) {
        Account acc = new Account("ICBC-001", 1000000);
        new DrawThread("Ming", acc).start();
        new DrawThread("Hong", acc).start();
    }
}
