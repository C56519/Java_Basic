package com.ethanc.interfacedemo;

// 接口的其他注意事项
// 2、一个接口继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承，也不支持多实现。
//      也就是多继承中，如果两个父类接口中存在同名方法，而且做不一样的操作，也就是签名冲突，子类接口继承过程中就会报错，实现类中也会报错
// 3、一个类继承了父类，又同时实现了接口，如果父类中和接口中有同名的默认方法，实现类会优先用父类的。
//      跟上面问题一样，只不过父类一个是普通父类，一个是接口类，然后一个实现类同时继承了那个普通父类，同时实现了那个接口类
//      声明语句中先extends再implements：class D extends A implements B{}
//      如果这个普通父类和接口类中存在同名方法，也就是签名冲突，那么实现类中会优先重写、调用传统父类的方法
// 4、一个类实现了多个接口，如果多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可。
//      依然是对应第二点，第二点强调继承两个签名冲突的那两个方法会报错，但是一旦子类重写了，就不报错，因为会优先使用重写的方法
// 5、 抽象类与接口的区别，见下
public class Test2 {
}

// 1、接口与接口可以多继承：一个接口可以同时继承多个接口
//      a. 类与类：单继承，一个类只能有一个父类
//      b. 类与接口：多实现，一个类可以同时实现多个接口
//      b. 接口与接口：多继承，一个接口可以继承多个接口
interface A {
    void show1();
}
interface B {
    void show2();
}
interface C extends A, B {
    void show3();
}
// 好处：
// 如果接口没有多继承特性，那么如果有一个实现类，那么必须实现三个接口：class D implements A, B, C
class D implements A, B, C {
    @Override
    public void show1() {}
    @Override
    public void show2() {}
    @Override
    public void show3() {}
}
// 但是有了接口的多继承的特性，那么可以在实现类中，只需要实现一个C接口即可，其他的C自动从AB继承了：class E implements C
class E implements C {
    @Override
    public void show1() {}
    @Override
    public void show2() {}
    @Override
    public void show3() {}
}

// 2、抽象类与接口的区别：
/*
相同点：
1、多是抽象形式， 都可以有抽象方法， 都不能创建对象。
2、都是派生子类形式：抽象类是被子类继承使用，接口是被实现类实现。
3、一个类继承抽象类，或者实现接口， 都必须重写它们的抽象方法，否则自己要成为抽象类或者报错！
4、都能支持多态，以实现解耦合。

不同点：
1、抽象类中可以定义类的全部普通成员，接口只能定义常量、抽象方法（JDK8 新增的三种方式）。
2、抽象类只能被类单继承，接口可以被类多实现。
3、一个类继承抽象类就不能再继承其他类，一个类实现了接口（还可以继承其他类或者实现其他接口）。
4、抽象类体现模板思想：更利于做父类，实现代码的复用性。 最佳实践
5、接口更适合做功能的解耦合；解耦合性更强更灵活。 最佳实践
*/
