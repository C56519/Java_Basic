package com.ethanc.set;
import java.util.HashSet;
import java.util.Set;
/*
 * HashSet集合的底层原理
 *
 * 1 首先了解哈希值
 * 哈希值：是一种增删改查数据，性能都较好的数据结构
 * - 就是一个int类型的随机值，Java中每个对象都有一个哈希值。
 * - Java中的所有对象，都可以调用Object类提供的hashCode方法，返回该对象自己的哈希值。public int hashCode(): 返回对象的哈希码值
 *
 * 对象哈希值的特点
 * - 同一个对象多次调用hashCode()方法返回的哈希值是相同的。
 * - 不同的对象，它们的哈希值大概率不相等，但也有可能会相等(哈希碰撞)。
 *      因为int类型范围(-21亿多 ~ 21亿多)，一旦存储的对象数量超过如45亿个，哈希碰撞的概率就非常高了。
 */
/*
 * 2 HashSet基于哈希表存储数据。
 * - JDK8之前，哈希表 = 数组 + 链表
 * - JDK8开始，哈希表 = 数组 + 链表 + 红黑树
 *
 * HashSet存储原理：
 * ① 创建一个默认长度16的数组，默认加载因子为0.75，数组名table
 *          也就是new的时候就创了个16长度的底层数组，当里面存了16 * 0.75 = 12 个元素时，开始扩容到原来长度的两倍，32
 * ② 使用元素的哈希值对数组的长度做运算计算出应存入的位置
 *          比如元素哈希值为16000，数组长度为16，则16000 % 16 = 0（只作为例子不代表实际算法），存入数组索引为0的位置
 *          （这里就说明了HashSet为什么是无序的）
 * ③ 判断当前位置是否为null，如果是null直接存入
 * ④ 如果不为null，表示有元素，则调用equals方法比较
 *    相等，则不存；（这也是为什么HashSet是不重复的）
 *    不相等，则存入数组执，执行其他逻辑比如拉链法、红黑树
 *
 * 不相等元素计算后，存入数组同一位置中的存储方式：
 * - JDK 8之前，新元素存入数组，占老元素位置，老元素挂下面
 * - JDK 8开始之后，新元素直接挂在老元素下面
 *
 * 好比在数组的这个位置上开始拉链法，挂元素。但会遇到问题，由于链表长度过长后查询等操作会很慢，
 * 所以JDK8开始，当链表长度超过8，且数组长度 >= 64时，自动将链表转成红黑树
 */
/*
 * 红黑树：
 *
 * 二叉树：普通二叉树、二叉查找树（二叉排序树）、平衡二叉树
 * 普通二叉树：直接存，
 *
 * 二叉排序树：会按一定顺序存，如：比根节点的元素大，存右边，比根节点的元素小，存左边
 * 二叉查找树存在的问题：当数据已经是排好序的，会导致数据都存在一边，像个链表，导致查询的性能下降
 *
 * 平衡二叉树
 * - 在满足查找二叉树的大小规则下，让树尽可能矮小，以此提高查数据的性能。
 * - 红黑树，就是可以自平衡的二叉树
 * - 红黑树是一种增删改查数据性能相对都较好的结构。
 */
public class Set2 {
    /*
    * 创建一个存储学生对象的集合，存储多个学生对象，要求：
    * 多个学生对象的成员变量值相同时，我们就认为是同一个对象，要求只保留一个。
    */
    public static void main(String[] args) {
        // 去重操作，可以想到使用Set集合，这里使用HashSet
        // 1 创建学生对象
        Student s1 = new Student("王明", 18, 98);
        Student s2 = new Student("李华", 18, 68);
        Student s3 = new Student("王明", 18, 98);
        Student s4 = new Student("李华", 18, 68);

        // 2 创建HashSet集合
        Set<Student> stuSet = new HashSet<Student>();

        // 3 添加元素
        stuSet.add(s1);
        stuSet.add(s2);
        stuSet.add(s3);
        stuSet.add(s4);

        // 打印
        // 这里重写了toString方法，使之输出对象的属性
        System.out.println(stuSet);
        // 可以看到，并没有去重，因为存的是对象，引用类型，会给不同的哈希值，会计算不同的底层数组索引

        // 解决：以存储对象的Set举例
        // 1. 底层源码中，Set 会计算每一个元素的哈希值，比如对象，会调用对象里的 .hashCode() 方法，计算出该对象的哈希值
        //    所以我们要重写Student类里的 .hashCode() 方法
        // 2. 继续观察底层源码，当计算哈希值后，准备存到数组中，这时候会有个判空操作，如果空，直接存
        //    如果不空，会调用元素对象的 .equals() 方法来判断新旧元素是否一样，
        //    所以我们要重写Student类里的 .equals() 来确定新旧元素的内容是否相同，相同的去重
    }
}
